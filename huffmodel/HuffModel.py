# -*- coding: utf-8 -*-
"""
/***************************************************************************
 HuffModel
                                 A QGIS plugin
 This plugin will allow users to quickly, and efficiently create a Huff Model.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-06-18
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Renacin Matadeen
        email                : renacin.matadeen@ryerson.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QVariant, QFileInfo
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QFileDialog


# From qgis.core import everything to give a greater level of functionality
from qgis.core import *
from qgis.utils import *
from qgis.gui import *

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
from .HuffModel_dialog import HuffModelDialog
import os
import os.path

# Import Processing For Spatial Algorithms
import processing

# ---------------------------------------------------------------------------


class HuffModel:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'HuffModel_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = HuffModelDialog()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Huff Model')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'HuffModel')
        self.toolbar.setObjectName(u'HuffModel')

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('HuffModel', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action



    # -----------------------------------------------------------------------

    # This Is Where The GUI Is Set

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/HuffModel/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Huff Model'),
            callback=self.run,
            parent=self.iface.mainWindow())
        self.load_clear()



    # -----------------------------------------------------------------------

    # This Is Where Most Of The Operational Functions Are Set



    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Huff Model'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar



    def removegroup(self, name):
        root = QgsProject.instance().layerTreeRoot()
        group = root.findGroup(name)
        if not group is None:
            for child in group.children():
                dump = child.dump()
                id = dump.split("=")[-1].strip()
                QgsProject.instance().removeMapLayer(id)
            root.removeChildNode(group)



    def removegroups(self):
        # Remove Before Running
        try:
            self.removegroup("Trade Areas")
        except:
            pass
        try:
            self.removegroup("Huff Model")
        except:
            pass



    def load_clear(self):
        """Clear & Populate Pertinent Fields & Entries"""

        # Clear Anything In The Drop-down Just In Case
        self.dlg.cb_inVector.clear()
        self.dlg.cb_inPointVector.clear()

        # Clear Text Fields
        self.dlg.le_inVectorField.clear()
        self.dlg.le_inPointVectorField.clear()

        # Populate Vector Drop-down
        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        # Create a New Layer To Store The Names Of Vector Layers
        vector_layers = []
        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                vector_layers.append(layer.name())

        self.dlg.cb_inVector.addItems(vector_layers)
        self.dlg.cb_inPointVector.addItems(vector_layers)



    def getinVector(self):
        """This will get the inVector layer data"""
        # Get The Name Of The Layer Then Loop Through The Layers In The TOC Looking For A Match
        layer = None
        layername = self.dlg.cb_inVector.currentText()
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == layername:
                layer = lyr
                break

        # Once A Match Has Been Found Break The Loop & Return
        return layer



    def getinPointVector(self):
        """This will get the inPointVector layer data"""
        # Get The Name Of The Layer Then Loop Through The Layers In The TOC Looking For A Match
        layer = None
        layername = self.dlg.cb_inPointVector.currentText()
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == layername:
                layer = lyr
                break

        # Once A Match Has Been Found Break The Loop & Return
        return layer



    def setVariables(self):
        """Get and set all variables from UI"""

        # Remember There Are Three Main Values From The UI
        self.inVector = self.getinVector()
        self.inPointVector = self.getinPointVector()
        self.inVectorVariable = self.dlg.le_inVectorField.text()
        self.inPointVariable = self.dlg.le_inPointVectorField.text()



    def clean_up(self):
        """Clean Up Past Attempts"""

        # Get Path
        self.inVector = self.getinVector()
        filepath = self.inVector.dataProvider().dataSourceUri()
        filepath_list = filepath.split("\\")
        layer_name = filepath_list[-1]
        filepath = filepath.replace(layer_name, "")

        # Clean Up Temp Files
        dir_list = os.listdir(filepath)

        # File Names
        file_names = ["Euclidean__DM.shp", "Huff__Model.shp", "Huff__Model__TAD.shp"]

        # File Extensions
        extensions = [".shp", ".dbf", ".prj", ".qpj", ".shx", "cpj"]

        for file_name in file_names:
            for extension in extensions:
                try:
                    os.remove(filepath + file_name + extension)
                except:
                    pass



    def check_inputs(self):
        """Checks To See If All Text Inputs Are Correct"""

        self.inVector = self.getinVector()
        self.inPointVector = self.getinPointVector()
        self.inVectorVariable = self.dlg.le_inVectorField.text()
        self.inPointVariable = self.dlg.le_inPointVectorField.text()
        self.inAttractiveness = self.dlg.le_inAttractiveness.text()
        prim = float(self.dlg.le_inPrimary.text())
        sec = float(self.dlg.le_inSecondary.text())

        # Insure That The Focus Fields Match The Fields Inside The Vector Layers

        # Check Inputs For First Vector
        fields = self.inVector.fields()
        field_names = []
        for field in fields:
            field_names.append(str(field.name()))

        # Compare With Entry
        raw_user_field = self.dlg.le_inVectorField.text()

        if raw_user_field in field_names:
            pass
        else:
            iface.messageBar().pushMessage("Input Error!", "Field Not In Polygon Layer", duration=4)
            raise IOError

        del fields, field_names

        # Check Inputs For Second Vector
        fields = self.inPointVector.fields()
        field_names = []
        for field in fields:
            field_names.append(str(field.name()))

        # Compare With Entry
        raw_user_field = self.dlg.le_inPointVectorField.text()

        if raw_user_field in field_names:
            pass
        else:
            iface.messageBar().pushMessage("Input Error!", "Field Not In Point Layer", duration=4)
            raise IOError

        del fields, field_names

        # Check Inputs For Attractiveness
        fields = self.inPointVector.fields()
        field_names = []
        for field in fields:
            field_names.append(str(field.name()))

        # Compare With Entry
        raw_user_field = self.dlg.le_inAttractiveness.text()

        if raw_user_field in field_names:
            pass
        else:
            iface.messageBar().pushMessage("Input Error!", "Field Not In Point Layer", duration=4)
            raise IOError

        del fields, field_names

        try:
            p = float(prim)
            s = float(sec)

        except:
            iface.messageBar().pushMessage("Input Error!", "Check Trade Area Values", duration=4)
            raise IOError



    def get_index(self, layer, field_text):

        # Get Features In Unique Identifier Field
        fields = layer.fields()
        field_names = []
        for field in fields:
            field_names.append(str(field.name()))

        # Unique Identifier Field
        point_field = -999
        counter_y = 0
        for field in field_names:
            if field == field_text:
                point_field = counter_y
                counter_y += 1
            else:
                counter_y += 1

        return point_field



    def make_centroid_layer(self):
        """From The Polygon Shapefile, Find The Centroids"""

        self.inVector = self.getinVector()
        filepath = self.inVector.dataProvider().dataSourceUri()
        filepath_list = filepath.split("\\")
        layer_name = filepath_list[-1]
        folderpath = filepath.replace(layer_name, "")

        counter_z = 0
        while counter_z < 501:
            try:
                processing.run("native:centroids", {"INPUT": self.getinVector(), "OUTPUT": folderpath + "Temp_Centroids.shp"})
                break
            except:
                counter_z += 1
                if counter_z == 500:
                    iface.messageBar().pushMessage("Error!", "File Inconsistency", duration=4)
                    raise IOError
                else:
                    pass



    def make_empty_copies(self):
        """Make Empty Copies Of The Polygon Layer To Store Pertinent Data"""

        # Get Layer Name
        self.inVector = self.getinVector()
        filepath = self.inVector.dataProvider().dataSourceUri()
        filepath_list = filepath.split("\\")
        layer_name = filepath_list[-1]
        filepath = filepath.replace(layer_name, "")

        # Get The Layer's CRS
        crs_ = self.inVector.crs().authid()
        crs = crs_.split(":")
        crs = crs[1]

        # Files To Create, Distance Matrix, Huff Probabilities, Trade Area Designations
        file_names = ["Euclidean__DM.shp", "Huff__Model.shp", "Huff__Model__TAD.shp"]

        # Make Three Copies Of The Polygon Vector Layer
        for file_name in file_names:
            QgsVectorFileWriter.writeAsVectorFormat(self.inVector, filepath + file_name, "CP1250", self.inVector.crs(), "ESRI Shapefile")

        # Get Feature IDs
        fields = self.inVector.fields()
        field_names = []
        for field in fields:
            field_names.append(str(field.name()))

        # Create A List Of Indices To Remove & Keep
        index_remove_list = []
        counter_x = 0
        for field in field_names:
            if field == self.dlg.le_inVectorField.text():
                index_keep = counter_x
                counter_x += 1
            else:
                index_remove_list.append(counter_x)
                counter_x += 1

        # Within Those Files Remove Everything Except The User Input Field
        for field in file_names:
            name = field.replace(".shp", "")
            target_layer = QgsVectorLayer(filepath + field, name, "ogr")

            # Delete Un-needed Fields
            target_layer.startEditing()
            target_layer.dataProvider().deleteAttributes(index_remove_list)
            target_layer.commitChanges()



    def prep_euclidean_huff_tad(self):
        """Prepare The Euclidean Distance File"""

        # Get Layer Name & Path Info
        self.inPointVector = self.getinPointVector()
        filepath = self.inPointVector.dataProvider().dataSourceUri()
        filepath_list = filepath.split("\\")
        layer_name = filepath_list[-1]
        filepath = filepath.replace(layer_name, "")

        point_field = self.get_index(self.inPointVector, self.dlg.le_inPointVectorField.text())

        # Get List Of Point Layer Identifiers
        data_all = []
        for feature in self.inPointVector.getFeatures():
            temp_list = []
            for attr in feature:
                temp_list.append(attr)
            data_all.append(temp_list)

        # Clean & Append Identifiers
        point_ids = []
        for values in data_all:
            identifier = values[point_field]
            identifier = str(identifier)
            try:
                identifier.replace(" ", "")
            except:
                pass
            point_ids.append(identifier)

        # In The Euclidean Distance Layer Write Every Entry As A New Field
        lyrOutput = QgsVectorLayer(filepath + "Euclidean__DM.shp", "Euclidean", "ogr")
        provider = lyrOutput.dataProvider()

        # The loop.
        for point in point_ids:
            # Add and name the field. Double type for distances.
            provider.addAttributes([QgsField(point, QVariant.Double)])
            lyrOutput.updateFields()
            lyrOutput.commitChanges()

        del lyrOutput

        # In The Huff Model Prob  Layer Write Every Entry As A New Field
        lyrOutput = QgsVectorLayer(filepath + "Huff__Model.shp", "Huff", "ogr")
        provider = lyrOutput.dataProvider()

        # The loop.
        for point in point_ids:
            # Add and name the field. Double type for distances.
            provider.addAttributes([QgsField(point, QVariant.Double)])
            lyrOutput.updateFields()
            lyrOutput.commitChanges()

        del lyrOutput

        # In The Huff Designation Layer Write Every Entry As A New Field
        lyrOutput = QgsVectorLayer(filepath + "Huff__Model__TAD.shp", "Huff_TAD", "ogr")
        provider = lyrOutput.dataProvider()

        # The loop.
        for point in point_ids:
            # Add and name the field. Double type for distances.
            provider.addAttributes([QgsField(point, QVariant.Int)])
            lyrOutput.updateFields()
            lyrOutput.commitChanges()



    def calc_euclidean(self):
        """Calculate The Euclidean Distance Between A Point & Polygon Centroid"""

        # Get Pertinent Layers, Point, Polygon Centroid, & Euclidean Dump File
        self.inPointVector = self.getinPointVector()
        lyrCentre = self.inPointVector
        filepath = self.inPointVector.dataProvider().dataSourceUri()
        filepath_list = filepath.split("\\")
        layer_name = filepath_list[-1]
        filepath = filepath.replace(layer_name, "")
        lyrConsumer = QgsVectorLayer(filepath + "Temp_Centroids.shp", "Centroids", "ogr")
        lyrOutput = QgsVectorLayer(filepath + "Euclidean__DM.shp", "Euclidean", "ogr")
        provider = lyrOutput.dataProvider()

        fldConsumerID_index = self.get_index(self.inVector, self.dlg.le_inVectorField.text())
        fldCentreID_index = self.get_index(self.inPointVector, self.dlg.le_inPointVectorField.text())

        # Set the output layer for editing.
        lyrOutput.startEditing()

        # Optimize feature request for outer nested loop.
        request1 = QgsFeatureRequest().setSubsetOfAttributes([self.dlg.le_inVectorField.text()], lyrConsumer.fields())

        # Set the output layer for editing.
        lyrOutput.startEditing()

        # Loop through each Consumer feature.
        for consumerFeature in lyrConsumer.getFeatures(request1):

            # Loop through each Centre feature.
            for centreFeature in lyrCentre.getFeatures():
                # Capture value of fldCentreID_index (current ID).
                currentCentreID = centreFeature[fldCentreID_index]

                # Create a measurement object.
                mObject = QgsDistanceArea()

                # Measure the euclidean distance.
                eDistance = mObject.measureLine(consumerFeature.geometry().asPoint(),
                                                centreFeature.geometry().asPoint())

                # Set the euclidean distance value of the new Centre field for
                # the current Consumer and Centre.
                distmatrix_field_index = self.get_index(lyrOutput, currentCentreID)
                lyrOutput.changeAttributeValue(consumerFeature.id(), distmatrix_field_index, eDistance)

        # Commit the changes to the layer.
        lyrOutput.commitChanges()



    def calc_huff(self):
        """Prepare The Huff Percentage Layer"""

        # Get Needed Info
        attr_field = self.dlg.le_inAttractiveness.text()
        self.inPointVector = self.getinPointVector()
        filepath = self.inPointVector.dataProvider().dataSourceUri()
        filepath_list = filepath.split("\\")
        layer_name = filepath_list[-1]
        filepath = filepath.replace(layer_name, "")


        # Get the layers
        lyrConsumer = QgsVectorLayer(filepath + "Euclidean__DM.shp", "Euclidean", "ogr")
        lyrCentre = self.inPointVector

        # Get the fields.
        fldCentreAttract_index = self.get_index(self.inPointVector, attr_field)
        fldCentreID_index = self.get_index(self.inPointVector, self.dlg.le_inPointVectorField.text())

        # Get The Exponent value
        expHuff = float(self.dlg.sb_HuffExponent.value())

        # Need to prepare output layer and add new field.
        # New field is "HP" plus the ID of the Centre.
        # Loop through each Centre to construct new field names.
        lyrOutput = QgsVectorLayer(filepath + "Huff__Model.shp", "Huff", "ogr")

        # Set the output layer for editing.
        lyrOutput.startEditing()

        # Loop through each Consumer feature.
        for consumerFeature in lyrConsumer.getFeatures():

            # Create a total variable for the sumJ of Sj/dij values for use in the nested loop.
            sumJ_sjdivdij = 0.0

            # Huff Formula: [(sj/(dij)^b)/(SUMj(sj/(dij)^b))] for a given consumer i and centre j.
            # sumJ_sjdivdij is the denominator of this formula and is first loop below.
            # Exponent b is for friction of distance of the product or service.
            # Second loop below calculates numerator and completes Huff calc for a given ij.

            # Loop through each Centre feature to calculate a consumer's sumJ_sjdivdij.
            # This is the Huff formula denominator.
            for centreFeature in lyrCentre.getFeatures():

                # Capture value of fldCentreID_index (current ID).
                currentCentreID = centreFeature[fldCentreID_index]

                # Capture value of fldCentreAttract_index (current Centre Attractiveness).
                currentCentreAttract = centreFeature[fldCentreAttract_index]

                # Capture distance value for this Centre and this Consumer.
                # currentCentreID should match to field name in attrib table.
                currentDistance = consumerFeature[currentCentreID]

                # Calculate Centre Attractiveness / Distance^b >> (Sj/dij**b)

                # If statement to manage computing cost of exponent calculation.
                if expHuff == 1:
                    sjdivdij = currentCentreAttract / currentDistance
                else:
                    sjdivdij = currentCentreAttract / (currentDistance ** expHuff)

                # Add new Sj/dij^b to sumJ_sjdivdij.
                sumJ_sjdivdij = sumJ_sjdivdij + sjdivdij

            # Loop through each Centre a second time to calculate Huff proportion.
            for centreFeature in lyrCentre.getFeatures():

                # Capture value of fldCentreID_index (current ID).
                currentCentreID = centreFeature[fldCentreID_index]

                # Capture value of fldCentreAttract_index (current Centre Attractiveness).
                currentCentreAttract = centreFeature[fldCentreAttract_index]

                # Capture distance value for this Centre and this Consumer.
                # currentCentreID should match to field name in attrib table.
                currentDistance = consumerFeature[currentCentreID]

                # Calculate Centre Attractiveness / Distance^b >> (Sj/dij**b)

                # If statement to manage computing cost of exponent calculation.
                if expHuff == 1:
                    sjdivdij = currentCentreAttract / currentDistance
                else:
                    sjdivdij = currentCentreAttract / (currentDistance ** expHuff)

                # Complete the Huff formula calculation.
                calcHuffI = sjdivdij / sumJ_sjdivdij

                # Set the value of the new Hi field for the current Consumer and Centre.
                Huff_field_index = self.get_index(lyrOutput, currentCentreID)
                lyrOutput.changeAttributeValue(consumerFeature.id(), Huff_field_index, calcHuffI)

        # Commit the changes to the layer.
        lyrOutput.commitChanges()



    def calc_tad_des(self):
        """Designate Each Geography"""

        # Get Needed Info
        self.inPointVector = self.getinPointVector()
        filepath = self.inPointVector.dataProvider().dataSourceUri()
        filepath_list = filepath.split("\\")
        layer_name = filepath_list[-1]
        filepath = filepath.replace(layer_name, "")

        # Get the layers.
        lyrValues = QgsVectorLayer(filepath + "Huff__Model.shp", "Huff", "ogr")
        lyrCentre = self.inPointVector
        fldCentreID_index = self.get_index(self.inPointVector, self.dlg.le_inPointVectorField.text())

        # Has The User Selected An Advanced Methodology?
        yes_button = self.dlg.rb_AdvancedChoice_Yes.isChecked()

        # Cater Limits To Choice
        if yes_button == True:
            prim_lim = float(self.dlg.le_inPrimary.text())
            sec_lim = float(self.dlg.le_inSecondary.text())
        else:
            prim_lim = 60.00
            sec_lim = 30.00

        # Scale Limits
        prim_lim = prim_lim / 100
        sec_lim = sec_lim / 100

        # Start Adding Trade Designations
        lyrOutput = QgsVectorLayer(filepath + "Huff__Model__TAD.shp", "Huff_TAD", "ogr")
        lyrOutput.startEditing()

        for consumerFeatures in lyrValues.getFeatures():

            for centreFeature in lyrCentre.getFeatures():
                # Capture value of fldCentreID_index (current ID).
                currentCentreID = centreFeature[fldCentreID_index]
                current_Value = float(consumerFeatures[currentCentreID])

                # Set Primary Trade Area
                if (current_Value >= prim_lim):
                    TradeAreaDesignation = 1

                # Set Secondary Trade Area
                elif (sec_lim < current_Value < prim_lim):
                    TradeAreaDesignation = 2

                # Set Other Trade Area
                else:
                    TradeAreaDesignation = 3

                current_Huff_field = currentCentreID
                TA_field_index = self.get_index(lyrOutput, current_Huff_field)
                lyrOutput.changeAttributeValue(consumerFeatures.id(), TA_field_index, TradeAreaDesignation)

        # Commit the changes to the layer.
        lyrOutput.commitChanges()



    def render(self):
        """Render Separate Trade Areas To The Users View"""

        # Create a group to hold the Huff Model Main Outputs.
        root = QgsProject.instance().layerTreeRoot()
        HuffModelGroup = root.addGroup("Huff Model")

        # Get Needed Info
        self.inPointVector = self.getinPointVector()
        filepath = self.inPointVector.dataProvider().dataSourceUri()
        filepath_list = filepath.split("\\")
        layer_name = filepath_list[-1]
        filepath = filepath.replace(layer_name, "")
        lyrCentre = self.inPointVector
        fldCentreID_index = self.get_index(self.inPointVector, self.dlg.le_inPointVectorField.text())

        # Has The User Selected An Advanced Methodology?
        yes_button = self.dlg.rb_AdvancedChoice_M_Yes.isChecked()

        # What Is Rendered Depends On The Users Choice
        if yes_button == True:
            # Create a group to hold the Huff Model Main Outputs.
            HuffModel_Mapping_Group = root.addGroup("Trade Areas")

            # Get Fields For Names
            tas = QgsVectorLayer(filepath + "Huff__Model__TAD.shp", "", "ogr")

            # Check Inputs For First Vector
            fields = tas.fields()
            field_names = []
            for field in fields:
                field_names.append(str(field.name()))

            # A Loop That Creates A Copy Of The TradeArea Shapefile For Each Centre, Name By IDs
            name_idx = 1
            for centreFeature in lyrCentre.getFeatures():

                # Get The ID of the Field
                currentCentreID = centreFeature[fldCentreID_index]
                current_ID = currentCentreID

                # Load Huff Trade Areas Layer To Interface.
                HuffModel_TradeAreas = QgsVectorLayer(filepath + "Huff__Model__TAD.shp", str(field_names[name_idx]), "ogr")
                QgsProject.instance().addMapLayer(HuffModel_TradeAreas, False)
                HuffModel_Mapping_Group.insertChildNode(1, QgsLayerTreeLayer(HuffModel_TradeAreas))

                # Create A Thematic Map
                name = current_ID
                layer = QgsProject.instance().mapLayersByName(name)[0]

                # get unique values for 'severity' field
                fni = self.get_index(layer, current_ID)
                unique_vals = layer.dataProvider().uniqueValues(fni)

                # define categories to use in symbology
                categories = []

                for val in unique_vals:
                    int_val = int(val)

                    # Define The Primary Trade Area Colours
                    if int_val == 1:

                        # initialise the default symbol for this geometry type
                        symbol = QgsSymbol.defaultSymbol(layer.geometryType())

                        # configure a symbol layer
                        layer_style = {}
                        layer_style['color'] = '%d, %d, %d' % (246, 4, 8)

                        layer_style['outline'] = '#ffffff'
                        symbol_layer = QgsSimpleFillSymbolLayer.create(layer_style)

                        # replace default symbol layer with the configured one
                        if symbol_layer is not None:
                            symbol.changeSymbolLayer(0, symbol_layer)
                        else:
                            print
                            "success"

                        # create renderer object
                        category = QgsRendererCategory(val, symbol, str(val))
                        # entry for the list of category items
                        categories.append(category)

                    # Define The Secondary Trade Area Colours
                    elif int_val == 2:

                        # initialise the default symbol for this geometry type
                        symbol = QgsSymbol.defaultSymbol(layer.geometryType())

                        # configure a symbol layer
                        layer_style = {}
                        layer_style['color'] = '%d, %d, %d' % (255, 207, 102)

                        layer_style['outline'] = '#ffffff'
                        symbol_layer = QgsSimpleFillSymbolLayer.create(layer_style)

                        # replace default symbol layer with the configured one
                        if symbol_layer is not None:
                            symbol.changeSymbolLayer(0, symbol_layer)
                        else:
                            pass

                        # create renderer object
                        category = QgsRendererCategory(val, symbol, str(val))
                        # entry for the list of category items
                        categories.append(category)

                    # Everything else gets skipped, and isn't rendered
                    else:
                        pass

                # create renderer object
                renderer = QgsCategorizedSymbolRenderer(current_ID, categories)

                # assign the created renderer to the layer
                if renderer is not None:
                    layer.setRenderer(renderer)

                layer.triggerRepaint()
                name_idx += 1

            # Load Huff Probability Layer To Interface.
            HuffModel_Probabilities = QgsVectorLayer(filepath + "Huff__Model.shp", "Huff Probabilities", "ogr")
            QgsProject.instance().addMapLayer(HuffModel_Probabilities, False)
            HuffModelGroup.insertChildNode(1, QgsLayerTreeLayer(HuffModel_Probabilities))

        else:
            # Load Huff Probability Layer To Interface.
            HuffModel_Probabilities = QgsVectorLayer(filepath + "Huff__Model.shp", "Huff Probabilities", "ogr")
            QgsProject.instance().addMapLayer(HuffModel_Probabilities, False)
            HuffModelGroup.insertChildNode(1, QgsLayerTreeLayer(HuffModel_Probabilities))



    # -----------------------------------------------------------------------

    # This Is The Function That Does The Main Work Of The Plugin
    def run(self):

        """Run method that performs all the real work"""
        # show the dialog
        self.dlg.show()

        # Run the dialog event loop
        result = self.dlg.exec_()

        # See if OK was pressed
        if result:

            # Insure That Inputs Are Correct & Clean DIR
            self.removegroups()
            self.check_inputs()
            self.clean_up()
            self.make_centroid_layer()
            self.make_empty_copies()
            self.prep_euclidean_huff_tad()
            self.calc_euclidean()
            self.calc_huff()
            self.calc_tad_des()
            self.render()

            iface.messageBar().pushMessage("Complete!: ", "Huff Model Successfully Created", duration=4)




